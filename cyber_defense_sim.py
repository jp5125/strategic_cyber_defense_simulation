# -*- coding: utf-8 -*-
"""Cyber_Strategic_Uncertainty.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kuD8dIN79AHVvJbFDM5VMLPfoIPbGlYL
"""

#Initial utility methods and model parameters

import numpy as np
import pandas as pd
from enum import IntEnum


#Utility methods

#clip01 keeps all continuous variables in the simulation bounded between [0,1]
def clip01(x):
  return np.clip(x, 0.0, 1.0)

# Enums for ensuring clean and explicit model events
class Action(IntEnum):
  PASSIVE = 0 # NIST CSF 2.0 Functions Identify + Protect
  ACTIVE = 1 # NIST CSF 2.0 Functions Detect + Respond
  RECOVER = 2 #Recover function

class AttackTarget(IntEnum):
  NONE = 0
  IT = 1
  OT = 2

class Intensity(IntEnum):
  NONE = 0
  LOW = 1
  HIGH = 2

# Model Parameters
Parameters = pd.Series({
    #Simulation Control
    "T" : 500,
    'Seed': 1,

    #Governance
    "G" : 0.6,

    #Initial Defender State variables
    "it_vuln_init" : 0.6,
    "ot_vuln_init" : 0.7,
    "id_cap_init" : 0.2,
    'it_comp_init' : 0,
    'ot_comp_init' : 0,
    'downtime_init' : 0.0,
    'phys_damage_init' : 0.0,

    #Attacker event process
    'p_attack': 0.35,
    'p_ot_given_attack_base' : 0.35,
    'p_ot_bonus_if_it_comp' : 0.20,
    'p_ot_bonus_if_ot_high_vuln' : 0.20,
    'ot_high_vuln_threshold': 0.7,

    #Attack intensity deterrence via identification
    'p_high_base' : 0.50,
    'k_deterrence' : 2.0,

    # Delta parameters for defender actions
    "delta_it_vuln": 0.04,
    "delta_ot_vuln": 0.02,
    "delta_id_cap": 0.03,

    "delta_detect": 0.25,
    "delta_contain": 0.25,
    "active_damage_reduction": 0.35,

    "delta_recover_clear": 0.30,
    "delta_downtime_reduction": 0.40,
})

#Reproducible randomness
rng = np.random.default_rng(int(Parameters["Seed"]))

print(Parameters)

#Simulation State Code

#Initialize state as a Pandas series
State = pd.Series({
    'it_vuln' : clip01(Parameters['it_vuln_init']),
    'ot_vuln' : clip01(Parameters['ot_vuln_init']),
    'id_cap' : clip01(Parameters['id_cap_init']),

    #defender compromised treated as boolean, flags [0,1] indicate whether defender IT or OT is compromised
    "it_comp" : int(Parameters['it_comp_init']),
    "ot_comp" : int(Parameters['ot_comp_init']),
    "downtime" : float(Parameters['downtime_init']),
    "phys_damage" : float(Parameters['phys_damage_init']),
    })

#Simulation time + log storage data structures
t = 0
rows = []

def gov_mult(Parameters):
  #baseline government multiplier = 0.5 + 0.5 * G
  return 0.5 + 0.5 * clip01(Parameters['G'])


def snapshot_state(Parameters, State, t):
  #returns a dictionary of the pre-action state we wish to record in the log
  return{
      't' : t,
      'G' : float(clip01(Parameters['G'])),
      'gov_mult': float(gov_mult(Parameters)),

      'it_vuln' : float(State['it_vuln']),
      'ot_vuln' : float(State['ot_vuln']),
      'id_cap' : float(State['id_cap']),

      'it_comp' : int(State['it_comp']),
      'ot_comp' : int(State['ot_comp']),
      'downtime' : float(State['downtime']),
      'phys_damage' : float(State['phys_damage']),
  }

def sim_step(Parameters, State, rng, t, rows):
  pre = snapshot_state(Parameters, State, t)

  #Placeholder policy: always PASSIVE for now (1/6/26)
  action = Action.PASSIVE

  B = apply_defender_action(Parameters, State, action)

  attack_target, intensity = sample_attacker_event(Parameters, State, rng)


  #Log row (attacker/outcomes will be added later)
  row = dict(pre)
  row.update({
     'action' : int(action),
     'action_name' : action.name,

     #log boosts to active defense values
     'detect_boost': float(B["detect_boost"]),
     'contain_boost': float(B["contain_boost"]),
     'recover_clear_boost': float(B['recover_clear_boost']),
     'downtime_reduction_boost': float(B['downtime_reduction_boost']),
     'active_damage_reduction': float(B['active_damage_reduction']),

     #attacker event
     'attack': int(attack_target),
     'attack_name': attack_target.name,
     'intensity': int(intensity),
     'intensity_name': intensity.name,
     'p_high': float(p_high_given_idcap(Parameters, State)),


     #Next state values
     'it_vuln_next' : float(State['it_vuln']),
     'ot_vuln_next' : float(State['ot_vuln']),
     'id_cap_next' : float(State['id_cap']),
    })

  rows.append(row)
  return t + 1 #advance time


def run_sim(Parameters, State, rng):
  rows_local = []
  t_local = 0

  for _ in range(int(Parameters['T'])):
    t_local = sim_step(Parameters, State, rng, t_local, rows_local)

  return pd.DataFrame(rows_local)

#Now, lets add some defense-effect parameters

def init_boosts():
    return pd.Series({
        "detect_boost": 0.0,
        "contain_boost": 0.0,
        "recover_clear_boost": 0.0,
        "downtime_reduction_boost": 0.0,
        "active_damage_reduction": 0.0
    })

def apply_defender_action(Parameters, State, action):
    gm = gov_mult(Parameters)
    B = init_boosts()

    if action == Action.PASSIVE:
        State["it_vuln"] = clip01(State["it_vuln"] - gm * Parameters["delta_it_vuln"])
        State["ot_vuln"] = clip01(State["ot_vuln"] - gm * Parameters["delta_ot_vuln"])
        State["id_cap"]  = clip01(State["id_cap"]  + gm * Parameters["delta_id_cap"])

    elif action == Action.ACTIVE:
        B["detect_boost"] = gm * Parameters["delta_detect"]
        B["contain_boost"] = gm * Parameters["delta_contain"]
        B["active_damage_reduction"] = clip01(gm * Parameters["active_damage_reduction"])

    elif action == Action.RECOVER:
        B["recover_clear_boost"] = gm * Parameters["delta_recover_clear"]
        B["downtime_reduction_boost"] = clip01(gm * Parameters["delta_downtime_reduction"])

    else:
        raise ValueError(f"Invalid action: {action}")

    return B

""" Implementation of the attacker process"""

def p_high_given_idcap(Parameters, State):
  """calculates the probability that the attacker will use a high intensity attack as a function of the identifying capabilities of the defender entity"""
  # P(HIGH) = p_high_base * exp(-k_deterrence * id_cap)

  return clip01(Parameters['p_high_base'] * np.exp(-Parameters['k_deterrence'] * State['id_cap']))

def sample_attacker_event(Parameters, State, rng):
  """
  After calculating the probability the attacker uses a high-intensity attack this timestep,
  We determine based on this probability if the attacker attacks this turn and if so,
  1. Is the target IT or OT infrastructure layer?
  2. Is the attack high or low intensity?
  """

  if rng.random() > Parameters['p_attack']:
    return(AttackTarget.NONE, Intensity.NONE)

  p_ot = Parameters['p_ot_given_attack_base']
  it_comp_bonus = Parameters['p_ot_bonus_if_it_comp']
  ot_vuln_bonus = Parameters['p_ot_bonus_if_ot_high_vuln']

  if State['it_comp'] == 1:
    if State['ot_vuln'] >= Parameters['ot_high_vuln_threshold']:
      p_ot = p_ot + it_comp_bonus + ot_vuln_bonus
    else:
      p_ot = p_ot + it_comp_bonus
  else:
    if State['ot_vuln'] >= Parameters['ot_high_vuln_threshold']:
      p_ot = p_ot + ot_vuln_bonus
    else:
      p_ot = p_ot

  p_ot = clip01(p_ot)
  target = AttackTarget.OT if rng.random() < p_ot else AttackTarget.IT


  p_high = p_high_given_idcap(Parameters, State)
  intensity = Intensity.HIGH if rng.random() < p_high else Intensity.LOW

  return target, intensity

#Debugging test to make sure Dataframe is produced as intended
df_test = run_sim(Parameters, State.copy(), rng)
df_test.head(10)

#Test of updated functionality, action == pasive should slowly reduce vulnerability and increase id_capability over time (1/6/26)
test2 = run_sim(Parameters, State.copy(), rng)
test2[['t', 'it_vuln', 'it_vuln_next', 'ot_vuln', 'ot_vuln_next', 'id_cap', 'id_cap_next']].head(10)

#Test of attacker functionality implemented on (1/15/26)
test3 = run_sim(Parameters, State.copy(), np.random.default_rng(int(Parameters["Seed"])))
test3[['t', 'id_cap', 'attack_name', 'intensity_name', 'p_high']].head(100)